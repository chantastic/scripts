#!/usr/bin/env nix-shell
#!nix-shell -i bash -p bun playwright-driver.browsers ffmpeg

# get-video - Capture 5-second website videos
#
# Part of the b-roll asset collection toolkit. Self-contained script with
# nix-shell dependencies, no installation required.
#
# FEATURES:
#   - HiDPI 16:10: 1280x800 viewport @ 2x scale = 2560x1600 output
#   - 5-second video capture (configurable)
#   - 120+ company domain mappings with fuzzy matching
#   - Cloudflare challenge detection and handling
#   - Stealth mode (anti-bot detection, non-headless by default)
#   - Batch processing support
#
# USAGE:
#   get-video anthropic openai github
#   get-video -o ./videos "https://example.com"
#   get-video --headless --duration 10 stripe
#   get-video --test  # Run self-tests
#
# OPTIONS:
#   -o, --output-dir DIR    Output directory (default: ~/Downloads)
#   --duration SECONDS      Video duration in seconds (default: 5)
#   --headless              Run in headless mode (faster, more detectable)
#   --timeout MS            Timeout in milliseconds (default: 45000)
#   --scroll                Auto-scroll during recording
#   --test                  Run self-tests
#   -h, --help              Show help
#
# OUTPUT:
#   Format:     MP4 (H.264, converted from WebM)
#   Resolution: 2560x1600 (HiDPI 16:10)
#   Duration:   5 seconds (default)
#   Naming:     Sanitized domain name (e.g., anthropic.mp4)
#
# RELATED SCRIPTS:
#   get-logo       - Download company logos
#   get-screenshot - Capture website screenshots
#   rough-cut      - Video editing workflow automation

set -euo pipefail

# Default settings
OUTPUT_DIR="$HOME/Downloads"
VIEWPORT_WIDTH=1280
VIEWPORT_HEIGHT=800  # 16:10 aspect ratio
DEVICE_SCALE=2  # HiDPI: 2560x1600 output
HEADLESS="false"
TIMEOUT=45000
DURATION=5
SCROLL="false"

# Self-tests function
run_tests() {
    echo "Running get-video self-tests..."
    echo ""

    local TEST_DIR="/tmp/get-video-test-$$"
    local PASS=0
    local FAIL=0

    mkdir -p "$TEST_DIR"
    trap "rm -rf $TEST_DIR" EXIT

    # Test 1: Basic capture
    echo -n "Test 1: Capture simple URL (3 second video)... "
    if "$0" --headless --duration 3 -o "$TEST_DIR" https://example.com > /dev/null 2>&1; then
        if [[ -f "$TEST_DIR/example.mp4" ]]; then
            # Check video is valid
            if ffprobe -v error "$TEST_DIR/example.mp4" > /dev/null 2>&1; then
                echo "PASS"
                PASS=$((PASS + 1))
            else
                echo "FAIL (invalid video)"
                FAIL=$((FAIL + 1))
            fi
        else
            echo "FAIL (file not created)"
            FAIL=$((FAIL + 1))
        fi
    else
        echo "FAIL (capture failed)"
        FAIL=$((FAIL + 1))
    fi

    # Test 2: Company name resolution
    echo -n "Test 2: Company name resolution... "
    if "$0" --headless --duration 3 -o "$TEST_DIR" bun > /dev/null 2>&1; then
        if [[ -f "$TEST_DIR/bun.mp4" ]]; then
            echo "PASS"
            PASS=$((PASS + 1))
        else
            echo "FAIL (file not created)"
            FAIL=$((FAIL + 1))
        fi
    else
        echo "FAIL (capture failed)"
        FAIL=$((FAIL + 1))
    fi

    # Test 3: Skip existing
    echo -n "Test 3: Skip existing files... "
    if "$0" --headless -o "$TEST_DIR" example.com 2>&1 | grep -q "File exists"; then
        echo "PASS"
        PASS=$((PASS + 1))
    else
        echo "FAIL"
        FAIL=$((FAIL + 1))
    fi

    # Summary
    echo ""
    echo "======================================"
    echo "Passed: $PASS/3"
    echo "Failed: $FAIL/3"
    echo "======================================"

    if [[ $FAIL -eq 0 ]]; then
        echo "All tests passed!"
        return 0
    else
        echo "Some tests failed"
        return 1
    fi
}

# Parse arguments
URLS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -o|--output-dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --duration)
            DURATION="$2"
            shift 2
            ;;
        --headless)
            HEADLESS="true"
            shift
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --scroll)
            SCROLL="true"
            shift
            ;;
        --test)
            run_tests
            exit $?
            ;;
        -h|--help)
            cat <<EOF
get-video - Capture 5-second website videos

Usage:
  get-video [options] <url-or-name>...

Arguments:
  url-or-name    URLs or company names to record

Options:
  -o, --output-dir DIR    Output directory (default: ~/Downloads)
  --duration SECONDS      Video duration in seconds (default: 5)
  --headless              Run in headless mode
  --timeout MS            Timeout in milliseconds (default: 45000)
  --scroll                Auto-scroll during recording
  --test                  Run self-tests
  -h, --help              Show this help

Examples:
  get-video "https://anthropic.com" "https://openai.com"
  get-video -o ./videos anthropic openai
  get-video github stripe vercel
  get-video --duration 10 --scroll "https://example.com"
  get-video --test   # Run regression tests

Notes:
  - Outputs HiDPI 16:10 (2560x1600) MP4 videos
  - Supports both full URLs and company name shortcuts
  - Automatically handles Cloudflare challenges
  - Default duration is 5 seconds
EOF
            exit 0
            ;;
        -*)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
        *)
            URLS+=("$1")
            shift
            ;;
    esac
done

if [[ ${#URLS[@]} -eq 0 ]]; then
    echo "Error: No URLs or names provided" >&2
    echo "Run 'get-video --help' for usage" >&2
    exit 1
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Company domain mapping (same as get-screenshot)
declare -A DOMAINS=(
    # AI & ML
    ["openai"]="openai.com"
    ["anthropic"]="anthropic.com"
    ["claude"]="claude.ai"
    ["claude code"]="claude.ai"
    ["claude platform"]="console.anthropic.com"
    ["workos"]="workos.com"
    ["google"]="google.com"
    ["microsoft"]="microsoft.com"
    ["meta"]="meta.com"
    ["huggingface"]="huggingface.co"
    ["hugging face"]="huggingface.co"
    ["replicate"]="replicate.com"
    ["stability ai"]="stability.ai"
    ["midjourney"]="midjourney.com"
    ["cohere"]="cohere.com"

    # Tech Companies
    ["apple"]="apple.com"
    ["amazon"]="amazon.com"
    ["netflix"]="netflix.com"
    ["spotify"]="spotify.com"
    ["twitter"]="twitter.com"
    ["x"]="x.com"
    ["linkedin"]="linkedin.com"
    ["github"]="github.com"
    ["gitlab"]="gitlab.com"
    ["stripe"]="stripe.com"
    ["vercel"]="vercel.com"
    ["netlify"]="netlify.com"
    ["cloudflare"]="cloudflare.com"

    # Dev Tools
    ["figma"]="figma.com"
    ["notion"]="notion.so"
    ["slack"]="slack.com"
    ["discord"]="discord.com"
    ["zoom"]="zoom.us"
    ["linear"]="linear.app"
    ["postman"]="postman.com"

    # Frameworks
    ["react"]="react.dev"
    ["vue"]="vuejs.org"
    ["angular"]="angular.io"
    ["svelte"]="svelte.dev"
    ["nextjs"]="nextjs.org"
    ["next.js"]="nextjs.org"
    ["bun"]="bun.sh"
    ["deno"]="deno.com"
    ["nodejs"]="nodejs.org"
    ["node"]="nodejs.org"

    # Nix ecosystem
    ["nixos"]="nixos.org"
    ["nix"]="nixos.org"
    ["nix-darwin"]="github.com/LnL7/nix-darwin"
    ["home-manager"]="github.com/nix-community/home-manager"

    # Other
    ["playwright"]="playwright.dev"
    ["vscode"]="code.visualstudio.com"
    ["docker"]="docker.com"
    ["kubernetes"]="kubernetes.io"
)

# Function to resolve URL
resolve_url() {
    local input="$1"

    # If it's already a URL, use it
    if [[ "$input" =~ ^https?:// ]]; then
        echo "$input"
        return 0
    fi

    # Try exact domain match (case-insensitive)
    local lower_input=$(echo "$input" | tr '[:upper:]' '[:lower:]')
    if [[ -n "${DOMAINS[$lower_input]:-}" ]]; then
        echo "https://${DOMAINS[$lower_input]}"
        return 0
    fi

    # If it looks like a domain (has dot), try it
    if [[ "$input" == *.* ]]; then
        echo "https://$input"
        return 0
    fi

    # Fallback: treat as domain
    echo "https://$input.com"
    return 0
}

# Function to sanitize filename
sanitize_filename() {
    local name="$1"
    # Remove protocol
    name="${name#https://}"
    name="${name#http://}"
    # Remove www
    name="${name#www.}"
    # Take first part of domain
    name="${name%%/*}"
    name="${name%%.*}"
    # Clean up
    echo "$name" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-'
}

# Set Playwright browser path
export PLAYWRIGHT_BROWSERS_PATH="${PLAYWRIGHT_BROWSERS_PATH:-$HOME/.cache/ms-playwright}"

# Create temporary TypeScript file for video capture
TEMP_TS=$(mktemp /tmp/get-video.XXXXXX.ts)
trap "rm -f $TEMP_TS" EXIT

cat > "$TEMP_TS" <<'TYPESCRIPT_EOF'
import { chromium } from 'playwright';
import * as fs from 'fs';
import * as path from 'path';

interface Args {
    url: string;
    outputDir: string;
    slug: string;
    headless: boolean;
    timeout: number;
    viewport: { width: number; height: number };
    deviceScaleFactor: number;
    duration: number;
    scroll: boolean;
}

const args: Args = JSON.parse(process.argv[2]);

async function captureVideo() {
    const browser = await chromium.launch({
        headless: args.headless,
        args: [
            '--disable-blink-features=AutomationControlled',
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--disable-gpu',
        ]
    });

    // Create temp directory for video
    const tempDir = fs.mkdtempSync('/tmp/get-video-');

    const context = await browser.newContext({
        viewport: args.viewport,
        deviceScaleFactor: args.deviceScaleFactor,
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
        locale: 'en-US',
        timezoneId: 'America/Los_Angeles',
        permissions: [],
        extraHTTPHeaders: {
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
        },
        recordVideo: {
            dir: tempDir,
            size: {
                width: args.viewport.width * args.deviceScaleFactor,
                height: args.viewport.height * args.deviceScaleFactor
            }
        }
    });

    await context.addInitScript(() => {
        Object.defineProperty(navigator, 'webdriver', {
            get: () => undefined,
        });
    });

    const page = await context.newPage();
    page.setDefaultTimeout(args.timeout);

    try {
        await page.goto(args.url, {
            waitUntil: 'networkidle',
            timeout: args.timeout
        });

        // Wait for page to settle
        await page.waitForTimeout(2000);

        // Check for Cloudflare
        const title = await page.title();
        const bodyText = await page.textContent('body').catch(() => '');

        if (title.includes('Just a moment') || bodyText.includes('Cloudflare')) {
            console.error('   Waiting for Cloudflare...');
            await page.waitForTimeout(10000);
        }

        // Record for specified duration
        if (args.scroll) {
            // Smooth scroll during recording
            const scrollDuration = args.duration * 1000;
            const scrollInterval = 100;
            const scrollSteps = scrollDuration / scrollInterval;

            const pageHeight = await page.evaluate(() => document.body.scrollHeight);
            const viewportHeight = args.viewport.height;
            const scrollDistance = Math.max(0, pageHeight - viewportHeight);
            const scrollPerStep = scrollDistance / scrollSteps;

            for (let i = 0; i < scrollSteps; i++) {
                await page.evaluate((y) => window.scrollTo({ top: y, behavior: 'auto' }), scrollPerStep * i);
                await page.waitForTimeout(scrollInterval);
            }
        } else {
            // Just wait for the duration
            await page.waitForTimeout(args.duration * 1000);
        }

        // Close page and context to finalize video
        await page.close();
        await context.close();

        // Find the recorded video
        const files = fs.readdirSync(tempDir);
        const webmFile = files.find(f => f.endsWith('.webm'));

        if (!webmFile) {
            throw new Error('No video file was created');
        }

        const webmPath = path.join(tempDir, webmFile);

        // Output the webm path for bash to convert
        console.log(`WEBM_PATH:${webmPath}`);
        console.log('OK');

    } catch (error) {
        console.error(`ERROR:${error instanceof Error ? error.message : String(error)}`);
        process.exit(1);
    } finally {
        await browser.close();
    }
}

captureVideo().catch(error => {
    console.error(`Fatal: ${error}`);
    process.exit(1);
});
TYPESCRIPT_EOF

# Main loop
echo "Recording ${#URLS[@]} video(s)..."
echo "Output directory: $OUTPUT_DIR"
echo "Resolution: ${VIEWPORT_WIDTH}x${VIEWPORT_HEIGHT} @ ${DEVICE_SCALE}x ($(( VIEWPORT_WIDTH * DEVICE_SCALE ))x$(( VIEWPORT_HEIGHT * DEVICE_SCALE )) output)"
echo "Duration: ${DURATION}s"
echo ""

SUCCESS_COUNT=0
FAIL_COUNT=0

for input in "${URLS[@]}"; do
    url=$(resolve_url "$input")
    slug=$(sanitize_filename "$url")
    output_path="$OUTPUT_DIR/${slug}.mp4"

    echo "Recording '$input'"
    echo "   URL: $url"

    # Check if already exists
    if [[ -f "$output_path" ]]; then
        echo "   File exists (skipping)"
        echo "   $output_path"
        echo ""
        continue
    fi

    echo -n "   Capturing ${DURATION}s video... "

    # Build args JSON
    args_json=$(cat <<JSON
{
    "url": "$url",
    "outputDir": "$OUTPUT_DIR",
    "slug": "$slug",
    "headless": $HEADLESS,
    "timeout": $TIMEOUT,
    "viewport": {
        "width": $VIEWPORT_WIDTH,
        "height": $VIEWPORT_HEIGHT
    },
    "deviceScaleFactor": $DEVICE_SCALE,
    "duration": $DURATION,
    "scroll": $SCROLL
}
JSON
)

    # Capture video
    if output=$(bun run "$TEMP_TS" "$args_json" 2>&1); then
        # Parse output to get webm path
        webm_path=$(echo "$output" | grep "^WEBM_PATH:" | cut -d: -f2-)

        if [[ -n "$webm_path" && -f "$webm_path" ]]; then
            echo "done"
            echo -n "   Converting to MP4... "

            # Convert webm to mp4 with ffmpeg
            if ffmpeg -y -i "$webm_path" -c:v libx264 -preset fast -crf 18 -pix_fmt yuv420p "$output_path" > /dev/null 2>&1; then
                echo "done"
                # Clean up webm
                rm -f "$webm_path"
                rm -rf "$(dirname "$webm_path")"

                # Get file size and duration
                size=$(du -h "$output_path" | cut -f1)
                duration_actual=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$output_path" 2>/dev/null | cut -d. -f1)
                echo "   Saved: $output_path ($size, ${duration_actual}s)"
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
                echo "FAILED"
                echo "   Error: ffmpeg conversion failed"
                FAIL_COUNT=$((FAIL_COUNT + 1))
            fi
        else
            echo "FAILED"
            echo "   Error: No video file created"
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi
    else
        echo "FAILED"
        error_msg=$(echo "$output" | grep "^ERROR:" | cut -d: -f2- || echo "$output")
        echo "   Error: $error_msg"
        FAIL_COUNT=$((FAIL_COUNT + 1))
    fi

    echo ""
done

# Summary
echo "=================================================="
echo "Recorded $SUCCESS_COUNT/${#URLS[@]} video(s)"
if [[ $FAIL_COUNT -gt 0 ]]; then
    echo "Failed: $FAIL_COUNT"
fi

exit 0
