#!/usr/bin/env python3
"""
Rough Cut - Video Timeline Generator

Generates Final Cut Pro timeline from video with automatic:
- Silence removal (ffmpeg silencedetect)
- Duplicate take detection (whisper transcript analysis)
- B-roll markers (proper noun detection)

Usage:
    rough-cut <video_path> [options]
    rough-cut --test         # Run tests

Outputs:
    <video>.json     - Whisper transcript
    <video>.fcpxml   - Final Cut Pro timeline

Example:
    rough-cut my-video.mov
    rough-cut my-video.mov --width 1920 --height 1080 --no-broll
"""

import argparse
import logging
import subprocess
import sys
import tempfile
import unittest
import uuid
from pathlib import Path

from rc_common import RoughCutError
from rc_audio import extract_audio, transcribe_audio, load_transcript, get_video_duration
from rc_silence import detect_silences, load_silences, invert_silences
from rc_takes import detect_takes
from rc_fcpxml import generate_fcpxml, get_transcript_for_segment

logging.basicConfig(
    level=logging.INFO,
    format='%(message)s'
)
logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(
        description='Generate Final Cut Pro timeline with automatic silence removal and take detection',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  rough-cut my-video.mov
  rough-cut my-video.mov --width 1920 --height 1080
  rough-cut my-video.mov --no-broll

Outputs:
  my-video.json     - Whisper transcript
  my-video.fcpxml   - Final Cut Pro timeline
        """
    )

    parser.add_argument('video_path', help='Path to video file')
    parser.add_argument('--width', type=int, help='Video width (default: auto-detect)')
    parser.add_argument('--height', type=int, help='Video height (default: auto-detect)')
    parser.add_argument('--post-roll', type=int, default=2, help='Post-roll frames (default: 2)')
    parser.add_argument('--min-speech', type=float, default=0.3, help='Min speech segment duration in seconds (default: 0.3)')
    parser.add_argument('--min-matching-words', type=int, default=3, help='Words to match for takes (default: 3)')
    parser.add_argument('--no-broll', action='store_true', help='Disable B-roll markers')
    parser.add_argument('--silence-threshold', type=int, default=-45, help='Silence threshold in dB (default: -45)')

    args = parser.parse_args()

    video_path = Path(args.video_path).resolve()
    if not video_path.exists():
        logger.error(f"Video file not found: {video_path}")
        sys.exit(1)

    video_stem = video_path.stem
    video_dir = video_path.parent
    transcript_path = video_dir / f"{video_stem}.json"
    fcpxml_path = video_dir / f"{video_stem}.fcpxml"

    session_id = str(uuid.uuid4())[:8]
    temp_audio = Path(tempfile.gettempdir()) / f"rough-cut-{session_id}-audio.wav"
    temp_silences = Path(tempfile.gettempdir()) / f"rough-cut-{session_id}-silences.txt"

    try:
        logger.info(f"Processing: {video_path.name}")
        logger.info("=" * 50)

        # 1. External tools
        extract_audio(video_path, temp_audio)
        transcribe_audio(temp_audio, transcript_path)
        logger.info(f"  Saved transcript: {transcript_path.name}")
        detect_silences(video_path, temp_silences, threshold_db=args.silence_threshold)

        # 2. Load data
        logger.info("\nLoading data...")
        transcript = load_transcript(transcript_path)
        logger.info(f"  {len(transcript)} transcript segments")

        silences = load_silences(temp_silences)
        duration = get_video_duration(video_path)
        logger.info(f"  Duration: {duration/60:.1f} min")

        # 3. Build speech intervals (single source of truth: silence inversion)
        logger.info("\nBuilding speech intervals...")
        speech_intervals = invert_silences(silences, duration, min_speech=args.min_speech)
        logger.info(f"  {len(speech_intervals)} speech intervals")

        total_speech = sum(s['duration'] for s in speech_intervals)
        logger.info(f"  Speech duration: {total_speech/60:.1f} min ({total_speech/duration*100:.0f}% of original)")

        # 4. Label intervals with transcript text
        logger.info("\nLabeling intervals with transcript...")
        for interval in speech_intervals:
            interval['text'], interval['indices'] = get_transcript_for_segment(
                transcript, interval['start'], interval['end'])

        # 5. Detect + remove duplicate takes
        logger.info("\nDetecting duplicate takes...")
        removes, take_markers = detect_takes(speech_intervals, args.min_matching_words)
        logger.info(f"  {len(removes)} takes to remove")
        final_intervals = [s for i, s in enumerate(speech_intervals) if i not in removes]

        # Remap take_markers to final_intervals indices
        final_markers = {}
        final_idx = 0
        for i, s in enumerate(speech_intervals):
            if i in removes:
                continue
            if i in take_markers:
                final_markers[final_idx] = take_markers[i]
            final_idx += 1

        # Auto-detect dimensions
        width = args.width
        height = args.height
        if not width or not height:
            try:
                result = subprocess.run(
                    ['mdls', '-name', 'kMDItemPixelWidth', '-name', 'kMDItemPixelHeight', str(video_path)],
                    capture_output=True, text=True, check=True
                )
                for line in result.stdout.split('\n'):
                    if 'kMDItemPixelWidth' in line:
                        width = int(line.split('=')[1].strip())
                    elif 'kMDItemPixelHeight' in line:
                        height = int(line.split('=')[1].strip())
            except Exception:
                width = width or 2560
                height = height or 1440

        # 6. Generate FCPXML
        logger.info("\nGenerating FCPXML...")
        fcpxml, timeline_frames = generate_fcpxml(
            final_intervals, final_markers, video_path,
            duration, width, height, args.post_roll, enable_broll=not args.no_broll
        )

        with open(fcpxml_path, 'w') as f:
            f.write(fcpxml)
        logger.info(f"  Saved timeline: {fcpxml_path.name}")

        # Summary
        logger.info("\n" + "=" * 50)
        logger.info("SUMMARY")
        logger.info("=" * 50)
        logger.info(f"Original duration:  {duration/60:.1f} min")
        logger.info(f"Final duration:     {timeline_frames/30/60:.1f} min")
        logger.info(f"Time saved:         {(duration - timeline_frames/30)/60:.1f} min ({(1 - timeline_frames/30/duration)*100:.0f}%)")
        logger.info(f"Clips:              {len(final_intervals)}")
        logger.info(f"Takes removed:      {len(removes)}")
        logger.info(f"\nOutputs:")
        logger.info(f"  {transcript_path}")
        logger.info(f"  {fcpxml_path}")

        logger.info("\nCleaning up...")
        temp_audio.unlink(missing_ok=True)
        temp_silences.unlink(missing_ok=True)

        logger.info("Done!")

    except RoughCutError as e:
        logger.error(f"\nError: {e}")
        temp_audio.unlink(missing_ok=True)
        temp_silences.unlink(missing_ok=True)
        sys.exit(1)
    except KeyboardInterrupt:
        logger.info("\n\nInterrupted by user")
        temp_audio.unlink(missing_ok=True)
        temp_silences.unlink(missing_ok=True)
        sys.exit(130)
    except Exception as e:
        logger.error(f"\nUnexpected error: {e}")
        temp_audio.unlink(missing_ok=True)
        temp_silences.unlink(missing_ok=True)
        sys.exit(1)


def run_tests():
    """Discover and run tests from tests/ directory"""
    print("Running rough-cut tests...")
    print("=" * 50)

    loader = unittest.TestLoader()
    tests_dir = Path(__file__).parent / 'tests'
    suite = loader.discover(str(tests_dir), pattern='test_*.py', top_level_dir=str(Path(__file__).parent))

    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)

    print("\n" + "=" * 50)
    if result.wasSuccessful():
        print(f"All {result.testsRun} tests passed!")
        return 0
    else:
        print(f"{len(result.failures)} failures, {len(result.errors)} errors")
        return 1


if __name__ == '__main__':
    if '--test' in sys.argv:
        sys.exit(run_tests())
    else:
        main()
