#!/usr/bin/env python3
"""
Export Cut - Export OTIO timeline to various formats

Exports an OpenTimelineIO timeline to:
- FCPXML (Final Cut Pro)
- ffmpeg (direct render via filter_complex)

Video dimensions are detected at export time (not stored in .otio) so the same
timeline can be exported at different resolutions without re-running rough-cut.

Usage:
    export-cut <otio_path> [options]

Examples:
    export-cut my-video.otio                    # default: FCPXML
    export-cut my-video.otio --format fcpxml
    export-cut my-video.otio --format ffmpeg --output my-video-edit.mp4
    export-cut my-video.otio --width 1920 --height 1080
"""

import argparse
import logging
import subprocess
import sys
import tempfile
from pathlib import Path

try:
    import opentimelineio as otio
except ImportError:
    print("Error: opentimelineio required. Install with: pip install opentimelineio")
    sys.exit(1)

from rc_export import generate_fcpxml_from_otio, generate_ffmpeg_filter

logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger(__name__)


def detect_dimensions(video_path):
    """Auto-detect video dimensions via mdls (macOS)"""
    try:
        result = subprocess.run(
            ['mdls', '-name', 'kMDItemPixelWidth', '-name', 'kMDItemPixelHeight', str(video_path)],
            capture_output=True, text=True, check=True
        )
        width = height = None
        for line in result.stdout.split('\n'):
            if 'kMDItemPixelWidth' in line:
                width = int(line.split('=')[1].strip())
            elif 'kMDItemPixelHeight' in line:
                height = int(line.split('=')[1].strip())
        if width and height:
            return width, height
    except Exception:
        pass
    return 2560, 1440


def main():
    parser = argparse.ArgumentParser(
        description='Export OTIO timeline to FCPXML or render via ffmpeg',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  export-cut my-video.otio                         # FCPXML (default)
  export-cut my-video.otio --format ffmpeg -o out.mp4
  export-cut my-video.otio --width 1920 --height 1080
        """
    )

    parser.add_argument('otio_path', help='Path to .otio file')
    parser.add_argument('--format', choices=['fcpxml', 'ffmpeg'], default='fcpxml',
                        help='Output format (default: fcpxml)')
    parser.add_argument('--output', '-o', help='Output path (default: auto)')
    parser.add_argument('--width', type=int, help='Video width (default: auto-detect)')
    parser.add_argument('--height', type=int, help='Video height (default: auto-detect)')

    args = parser.parse_args()

    otio_path = Path(args.otio_path).resolve()
    if not otio_path.exists():
        logger.error(f"File not found: {otio_path}")
        sys.exit(1)

    logger.info(f"Loading: {otio_path.name}")
    timeline = otio.adapters.read_from_file(str(otio_path))

    rc_meta = timeline.metadata.get("rough-cut", {})
    video_path = rc_meta.get("source_video", "")

    if not video_path or not Path(video_path).exists():
        logger.error(f"Source video not found: {video_path}")
        sys.exit(1)

    if args.format == 'fcpxml':
        output_path = Path(args.output) if args.output else otio_path.with_suffix('.fcpxml')

        width = args.width
        height = args.height
        if not width or not height:
            width, height = detect_dimensions(video_path)

        logger.info(f"Generating FCPXML ({width}x{height})...")
        fcpxml, timeline_offset = generate_fcpxml_from_otio(timeline, width, height)

        with open(output_path, 'w') as f:
            f.write(fcpxml)

        fps = rc_meta.get("fps", 30)
        logger.info(f"  Duration: {timeline_offset/fps/60:.1f} min")
        logger.info(f"  Saved: {output_path}")

    elif args.format == 'ffmpeg':
        output_path = Path(args.output) if args.output else otio_path.with_suffix('.mp4')

        logger.info("Generating ffmpeg filter...")
        filter_script = generate_ffmpeg_filter(timeline)

        # Write filter to temp file (avoids command line length limits)
        filter_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
        filter_file.write(filter_script)
        filter_file.close()

        logger.info(f"Rendering to {output_path.name}...")
        cmd = [
            'ffmpeg', '-i', video_path,
            '-filter_complex_script', filter_file.name,
            '-map', '[outv]', '-map', '[outa]',
            str(output_path), '-y'
        ]

        try:
            subprocess.run(cmd, check=True)
            logger.info(f"  Saved: {output_path}")
        except subprocess.CalledProcessError as e:
            logger.error(f"ffmpeg failed: {e}")
            sys.exit(1)
        finally:
            Path(filter_file.name).unlink(missing_ok=True)


if __name__ == '__main__':
    main()
